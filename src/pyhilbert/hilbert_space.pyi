from __future__ import annotations

from abc import ABC
from collections import OrderedDict
from collections.abc import Iterable, Iterator
from typing import (
    Any,
    Callable,
    Dict,
    Generic,
    NamedTuple,
    Tuple,
    Type,
    TypeVar,
    Union,
    overload,
)

import sympy as sy

from .abstracts import AbstractKet, Functional, HasUnit, Operable, Span
from .spatials import Spatial
from .state_space import StateSpace, StateSpaceFactorization
from .tensors import Tensor
from .utils import FrozenDict

_IrrepType = TypeVar("_IrrepType")
_ObservableType = TypeVar("_ObservableType")
_OperableType = TypeVar("_OperableType", bound=Operable)

class Ket(Generic[_IrrepType], AbstractKet[int], Operable):
    irrep: _IrrepType
    def __init__(self, irrep: _IrrepType) -> None: ...
    def ket(self, another: Ket[_IrrepType]) -> int: ...
    def __lt__(self, other: Ket[_IrrepType]) -> bool: ...
    def __gt__(self, other: Ket[_IrrepType]) -> bool: ...
    @overload
    def __matmul__(self, other: Ket[Any]) -> U1Basis: ...
    @overload
    def __matmul__(self, other: U1Basis) -> U1Basis: ...
    def __eq__(self, value: object) -> bool: ...

class U1Basis(Spatial, AbstractKet[sy.Expr], HasUnit):
    irrep: sy.Expr
    kets: Tuple[Ket[Any], ...]
    def __init__(self, irrep: sy.Expr, kets: Tuple[Ket[Any], ...]) -> None: ...
    @property
    def dim(self) -> int: ...
    def replace(self, irrep: Any) -> U1Basis: ...
    def irrep_of(self, T: Type[_IrrepType]) -> _IrrepType: ...
    def ket(self, psi: U1Basis) -> sy.Expr: ...
    def unit(self) -> U1Basis: ...
    def canonical_repr(self) -> Tuple[Any, ...]: ...
    def __lt__(self, other: U1Basis) -> bool: ...
    def __gt__(self, other: U1Basis) -> bool: ...
    @overload
    def __matmul__(self, other: Ket[Any]) -> U1Basis: ...
    @overload
    def __matmul__(self, other: U1Basis) -> U1Basis: ...
    @overload
    def __or__(self, other: U1Basis) -> U1Span: ...
    @overload
    def __or__(self, other: U1Span) -> U1Span: ...
    def __eq__(self, value: object) -> bool: ...

class U1Span(Span[U1Basis, sy.ImmutableDenseMatrix], Spatial, HasUnit):
    span: Tuple[U1Basis, ...]
    def __init__(self, span: Tuple[U1Basis, ...]) -> None: ...
    @property
    def dim(self) -> int: ...
    def __iter__(self) -> Iterator[U1Basis]: ...
    def elements(self) -> Tuple[U1Basis, ...]: ...
    def unit(self) -> U1Span: ...
    def gram(self, ket: U1Span) -> sy.ImmutableDenseMatrix: ...
    @overload
    def __or__(self, other: U1Basis) -> U1Span: ...
    @overload
    def __or__(self, other: U1Span) -> U1Span: ...
    def __sub__(self, other: U1Span) -> U1Span: ...
    def __and__(self, other: U1Span) -> U1Span: ...

U1Elements = Union[U1Basis, U1Span]

class HilbertSpace(HasUnit, StateSpace[U1Elements], Span[U1Elements, Tensor]):
    def __init__(self, structure: OrderedDict[U1Elements, slice]) -> None: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...

    class GroupResult(NamedTuple):
        spans: FrozenDict[str, U1Span]
        mapping: Tensor

    class GroupByResult(NamedTuple):
        groups: Tuple[U1Span, ...]
        mapping: Tensor

    def lookup(self, query: Dict[Type[Any], Any]) -> U1Basis: ...
    def flatten(self) -> HilbertSpace: ...
    def elements(self) -> Tuple[U1Basis, ...]: ...
    def group(self, **groups: Union[Callable[[U1Basis], bool], Any]) -> GroupResult: ...
    def group_by(self, *T: Type[Any]) -> GroupByResult: ...
    def is_homogeneous(self) -> bool: ...
    def factorize(
        self, *irrep_types: Tuple[Type[Any], ...]
    ) -> StateSpaceFactorization: ...
    def unit(self) -> HilbertSpace: ...
    def gram(self, another: HilbertSpace) -> Tensor: ...

def hilbert(itr: Iterable[U1Elements]) -> HilbertSpace: ...
@overload
def same_span(a: HilbertSpace, b: HilbertSpace) -> bool: ...
@overload
def same_span(a: U1Basis, b: U1Basis) -> bool: ...
@overload
def same_span(a: U1Span, b: U1Span) -> bool: ...

class U1Operator(Generic[_ObservableType], Functional, Operable, ABC):
    @overload
    def apply(self, v: U1Basis, **kwargs: Any) -> Tuple[_ObservableType, U1Basis]: ...
    @overload
    def apply(self, obj: Any, **kwargs: Any) -> Any: ...
    def eigen_opr(self) -> U1Operator[_ObservableType]: ...
    def __matmul__(self, other: _OperableType) -> _OperableType: ...

class FuncOpr(Generic[_IrrepType], U1Operator[sy.Integer]):
    T: Type[_IrrepType]
    func: Callable[..., Any]
    def __init__(self, T: Type[_IrrepType], func: Callable[..., Any]) -> None: ...

@overload
def operator_lt(a: Ket[_IrrepType], b: Ket[_IrrepType]) -> bool: ...
@overload
def operator_lt(a: U1Basis, b: U1Basis) -> bool: ...
@overload
def operator_gt(a: Ket[_IrrepType], b: Ket[_IrrepType]) -> bool: ...
@overload
def operator_gt(a: U1Basis, b: U1Basis) -> bool: ...
@overload
def operator_eq(a: Ket[Any], b: Ket[Any]) -> bool: ...
@overload
def operator_eq(a: U1Basis, b: U1Basis) -> bool: ...
@overload
def operator_matmul(o: U1Operator[Any], v: _OperableType) -> _OperableType: ...
@overload
def operator_matmul(a: Ket[Any], b: Ket[Any]) -> U1Basis: ...
@overload
def operator_matmul(psi: U1Basis, ket: Ket[Any]) -> U1Basis: ...
@overload
def operator_matmul(ket: Ket[Any], psi: U1Basis) -> U1Basis: ...
@overload
def operator_matmul(a: U1Basis, b: U1Basis) -> U1Basis: ...
@overload
def operator_or(a: U1Basis, b: U1Basis) -> U1Span: ...
@overload
def operator_or(span: U1Span, state: U1Basis) -> U1Span: ...
@overload
def operator_or(state: U1Basis, span: U1Span) -> U1Span: ...
@overload
def operator_or(a: U1Span, b: U1Span) -> U1Span: ...
def operator_sub(a: U1Span, b: U1Span) -> U1Span: ...
def operator_and(a: U1Span, b: U1Span) -> U1Span: ...
